#!/usr/bin/python
"""Convert a raw encoded e-mail to text

* Extract body text from multi-part (e-mail with attachments)
* Decrypts if necessary

Options:

    -i  --inplace   Simplify e-mail in place

"""

import sys
import email
import email.header

import getopt

import quopri
import base64

import codecs
import string

from htmlentitydefs import name2codepoint

import re

import executil

class Error(Exception):
    pass

from StringIO import StringIO

def usage(e=None):
    if e:
        print >> sys.stderr, "error: " + str(e)
    print >> sys.stderr, "Syntax: %s [ -i ] filename|- ..." % sys.argv[0]
    print >> sys.stderr, __doc__.strip()
    sys.exit(1)

    return payload


def get_body_text(message):
    if not message.is_multipart():
        parts = [ message ]
    else:
        parts = message.get_payload()

    for part in parts:
        payload = part.get_payload()

        content_type = part.get('content-type')
        if "PGP MESSAGE" in payload:
            payload = executil.getoutput_popen(["gpg", "--batch"], input=payload)

            if not content_type:
                return payload, None

        content_description = part.get('content-description')
        if content_description and 'encrypted message' in content_description:
            return get_body_text(email.message_from_string(payload))

        encoding = part.get('content-transfer-encoding')
        if encoding:
            if encoding == 'quoted-printable':
                payload = quopri.decodestring(payload)

            elif encoding == 'base64':
                payload = base64.decodestring(payload)

        if content_type:
            m = re.search(r'charset=([\w\d\-]+)', message['content-type'])
            if m:
                charset = m.group(1)
                try:
                    payload = codecs.decode(payload, charset)
                except:
                    pass

            if 'text/plain' in content_type:
                return payload, content_type

    # go one layer deeper if we can't find a message in the first layer
    if message.is_multipart():
        payload = message.get_payload()
        if payload:
            return get_body_text(payload[0])

    else:
        return payload, content_type

    raise Error("can't get message body")

def htmlentitydecode(s):
    return re.sub('&(%s);' % '|'.join(name2codepoint),
            lambda m: unichr(name2codepoint[m.group(1)]), s)

def html2txt(buf):
    buf = re.sub(r'\s+', ' ', buf)
    buf = re.sub('<BR\s*/?>', '\n', buf, 0, re.IGNORECASE)

    # strip tags
    buf = re.sub(r'</?\w+[^>]*>', '', buf)

    # strip tag comments
    buf = re.sub(r'<!--[^>]*-->', '', buf)

    buf = htmlentitydecode(buf).replace(u'\xa0', ' ')
    buf = re.sub(r'^[ ]+', '', buf, 0, re.MULTILINE)

    return buf

def filter_printable(s):
    return filter(lambda c: c in string.printable, s)

def decode_header(value):
    def simplify_whitespace(s):
        return re.sub(r'[\n\t]+', ' ', s)
    
    value = simplify_whitespace(value)

    value, encoding = email.header.decode_header(value)[0]
    try:
        if encoding:
            value = codecs.decode(value, encoding)
    except:
        pass

    value = simplify_whitespace(value)
    value = filter_printable(value)

    return value

def mail2txt(fp):
    old = email.message_from_file(fp)
    text, content_type = get_body_text(old)

    if content_type:
        if 'text/html' in content_type:
            text = html2txt(text)

    sio = StringIO()
    for field in ("Subject", "From", "To", "Date"):
        print >> sio, "%s: %s" % (field, decode_header(old[field]))

    print >> sio
    print >> sio, filter_printable(text),

    return sio.getvalue()

def main():
    try:
        opts, args = getopt.gnu_getopt(sys.argv[1:], "ih", 
                                       ["inplace"])
    except getopt.GetoptError, e:
        usage(e)

    inplace = False
    for opt, val in opts:
        if opt == '-h':
            usage()

        if opt in ('-i', '--inplace'):
            inplace = True

    if not args:
        usage()

    for input in args:
        if input == '-':
            if inplace:
                usage("can't use --inplace on stdin")
            input_fp = sys.stdin
        else:
            input_fp = file(input)

        text = mail2txt(input_fp)
        if not inplace:
            print text

        else:
            file(input, "w").write(text)

if __name__ == "__main__":
    main()
