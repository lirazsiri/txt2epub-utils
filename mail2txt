#!/usr/bin/python
"""Convert a raw encoded e-mail to text

* Extract body text from multi-part (e-mail with attachments)
* Decrypts if necessary

Options:

    -i  --inplace   Simplify e-mail in place

"""

import sys
import email
import email.header

import getopt
import quopri
import codecs
import string

from htmlentitydefs import name2codepoint

import re

import executil

class Error(Exception):
    pass

from StringIO import StringIO

def usage(e=None):
    if e:
        print >> sys.stderr, "error: " + str(e)
    print >> sys.stderr, "Syntax: %s [ -i ] filename|- ..." % sys.argv[0]
    print >> sys.stderr, __doc__.strip()
    sys.exit(1)

def decode_payload(message):
    payload = message.get_payload()

    if "PGP MESSAGE" in payload:
        payload = executil.getoutput_popen(["gpg", "--batch"], input=payload)

    if message['content-transfer-encoding'] == 'quoted-printable':
        payload = quopri.decodestring(payload)

    if message['content-type']:
        m = re.search(r'charset=([\w\d\-]+)', message['content-type'])
        if m:
            charset = m.group(1)
            try:
                payload = codecs.decode(payload, charset)
            except:
                pass

    return payload

def get_body_text(message):
    if not message.is_multipart():
        return decode_payload(message), message['content-type']

    for part in message.get_payload():
        if 'text/plain' in part['content-type']:
            return decode_payload(part), part['content-type']

        content_description = part.get('content-description')
        if content_description and 'encrypted message' in content_description:
            return get_body_text(email.message_from_string(decode_payload(part)))

    # go one layer deeper if we can't find a message in the first layer
    payload = message.get_payload()
    if payload:
        return get_body_text(payload[0])

    raise Error("can't get message body")

def htmlentitydecode(s):
    return re.sub('&(%s);' % '|'.join(name2codepoint),
            lambda m: unichr(name2codepoint[m.group(1)]), s)

def html2txt(buf):
    buf = re.sub('<BR>', '\n', buf, 0, re.IGNORECASE)

    # strip tags
    buf = re.sub(r'</?\w+[^>]*>', '', buf)

    # strip tag comments
    buf = re.sub(r'<!--[^>]*-->', '', buf)

    #import pdb; pdb.set_trace()
    buf = htmlentitydecode(buf).replace(u'\xa0', ' ')

    return buf

def mailsimplify(fp):
    old = email.message_from_file(fp)
    text, content_type = get_body_text(old)

    if content_type:
        if 'text/html' in content_type:
            text = html2txt(text)

    if content_type is None:
        content_type = "text/plain"

    new = email.Message.Message()
    for header in ("Subject", "From", "To", "Date"):
        new.add_header(header, old[header])

    new.set_payload(text)
    new.set_type(content_type)

    return new

def filter_printable(s):
    return filter(lambda c: c in string.printable, s)

def mail2txt(fp):
    m = mailsimplify(fp)

    sio = StringIO()
    def header(field):

        def simplify_whitespace(s):
            return re.sub(r'[\n\t]', ' ', s)
        
        value = simplify_whitespace(m[field])

        value, encoding = email.header.decode_header(value)[0]
        try:
            if encoding:
                value = codecs.decode(value, encoding)
        except:
            pass

        value = simplify_whitespace(value)
        value = filter_printable(value)

        return value

    print >> sio, "From: " + header('From')
    print >> sio, "To: " + header('To')

    print >> sio, 'Date: ' + header('Date')
    print >> sio, "Subject: " + header('Subject')

    print >> sio
    print >> sio, m.get_payload()

    text = sio.getvalue()

    # encoding of non-printable characters is hell
    text = filter_printable(text)

    return text

def main():
    try:
        opts, args = getopt.gnu_getopt(sys.argv[1:], "ih", 
                                       ["inplace"])
    except getopt.GetoptError, e:
        usage(e)

    inplace = False
    for opt, val in opts:
        if opt == '-h':
            usage()

        if opt in ('-i', '--inplace'):
            inplace = True

    if not args:
        usage()

    for input in args:
        if input == '-':
            if inplace:
                usage("can't use --inplace on stdin")
            input_fp = sys.stdin
        else:
            input_fp = file(input)

        text = mail2txt(input_fp)
        if not inplace:
            print codecs.encode(text, 'ascii', 'ignore')

        else:
            file(input, "w").write(str(text))

if __name__ == "__main__":
    main()
